# Written By JeonKa
## 주의사항
1. 최대값을 보고 ```long``` 또는 ```int``` 를 결정한다.

## 단순 구현
> 주로 문제의 규칙을 찾은 후 규칙대로 구현하는 문제들  
> 구현에는 크게 어려움이 없으나 규칙을 찾고 설계하는것이 어렵다.
> 효율성을 위해 메모리제이션이 가능한지 판단한다.
#### 대표유형
책 페이지 https://www.acmicpc.net/problem/1019  
제곱 ㄴㄴ 수 https://www.acmicpc.net/problem/1016  
#### 메모리제이션 
1. **Check** 용 배열을 선언할 시 ```max``` 와 ```min``` 의 값이 주어진 경우 인덱싱을 하여 배열의 크기를 ```max-min+1```로 선언한다.  
=  _이는 배열 사용 시 ```접근 인덱스 - min``` 을 해서 사용한다._

## 동자수열 
> 같은 것이 있는 경우의 순열  
> n개 중에 r개를 뽑은 경우에 대해서 중복인 원소가 있는 경우를 말한다.   	
- aab 를 예로 든다면 총 **3가지 원소를 나열하는 방법은 3!** 중, **aa가 중복** 되므로 **2!** 만큼 **빼주면** 된다. 3! - 2!   
- aaabbb 를 예로 든다면, 총 **6가지 원소를 나열하는 방법은 6!** 중, **aaa, bbb, 가 중복** 이므로 **3!을 두번** 빼주면 된다. 6! - 3! - 3!  
#### 대표유형
크리스마스 트리 https://www.acmicpc.net/problem/1234  


## 유클리드 호제법 ( GCD ) 
> 두 수의 최대 공약수를 구하는 알고리즘
1. 두 수중 작은 수가 0이 될 때 까지 나머지 연산을 한다.
2. 기본적으로 a > b 를 전제로 하나, b > a 로 입력값이 들어와도 나머지 연산을 통해 수가 뒤집어지므로 크게 상관은 없다.
```
int gcd (int A, int B ){
	int a = A;
	int b = B;
	while(b != a ){
		int r = a % b;
		a = b;
		b = r;
	}
	return a;
}
```
#### 최소 공배수(LCM) 구하기
1. 입력받은 두 수와 최대공약수를 통해 구할 수 있다.
```
int LCM(int A, int B, int gcd){
	return A * B / gcd;
}
```

## 분할정복
> 주로 거듭제곱 혹은 곱을 하는 과정에서 범위가 클 경우 사용
- Ex) 10^10 을 구하는 과정을 예로 들 경우   
=>  10^10  
=>  A = (10^5), A * A   
=>  B = (10^2 * 10^2 * 10), B * B   
=>  C = 10 * 10, C * C * 10 * C * C * 10 으로 한다.  
```
int function(int number, int curNum){
	int ret ;
	if( curNum == 1 ){
		ret = number;
	}
```
- 1일 경우 원래 거듭제곱을 하는 수 반환
```
	else if( curNum % 2 == 0){
		int A = function(number,curNum/2);
		ret = A*A;
	}
```
- 짝수일 경우 2로 나눈 값을 메모리제이션 한 후 그것을 제곱해서 반환
```
	else{
		int A  = function(number,curNum-1);
		ret = A * number;
	}
	return ret;
}
```
- 홀수일 경우 원래 거듭제곱을 하는 수 * 1 작은 수 만큼 거듭제곱 후 반환
#### 대표문제
피보나치 수 합https://www.acmicpc.net/problem/2086

## 오일러 서로소 개수 공식
> 1 - N 까지의 수 중 N 과 서로소인 수 의 개수 구하기  
> 서로소 : 두 양수 a, b 가 있을 때 a = xy b = xz ( x > 1, y > 0, z > 0 ) 인 a, b는 서로소이다.
#### 1에서 N 까지 N 과 서로소인 수 구하는 방법.
1. N의 약수를 구한다. ( 최대한 간단하게 표기 )   
2. 각 수의 지수는 무시하고 밑 만 고려한다.  
3. 만약 N의 약수의 종류가 a, b, c 일 경우 N 의 서로소 개수는  = N*(1-1/a)(1-1/b)(1-1/c) 이다.
```
int ans = N;
            for(int i = 2; i <= N ; i ++){
                if(N%i != 0)continue;
                while(N%i == 0){
                    N = N / i; // 방금 구한 밑으로 된 수로 나누어 떨어질 때 까지 나눈다.
                }
                ans = ans - ans / i ;
            }
            sb.append(ans).append("\n");
```
#### 대표문제 
서로소 https://www.acmicpc.net/problem/4355

---

## 트리
1. **트리의 지름** 을 구하는 방법은 **임의의 정점에서 가장 먼 정점** 을 구한 후 **구해진 정점에서 가장 먼 정점** 까지의 **거리** 가 **트리의 지름** 이다.



- UpperBound : 상한의 최저/ LowerBound : 하한의 최고  
	( Tree의 ceilingEntry() 를 통해 얻을 수 있다.)
- 실수의 값은 ```==``` 로 비교할 수 없다. 따라서 **이분탐색** 을 할 경우 ```while(left <= right)``` 와 같은 코드가 아닌 ```for문``` 을 통해 이분탐색을 해야한다. ```for문``` 의 최대 반복 횟수는 **오차 허용 범위 * 0.1 의 역수까지** 이다.  
Ex) 오차범위가 10^-3 일 경우 **10^-3 * 10^-1 = 10^-4 의 역수는 10000 ** 로 한다!!
- 가중치가 있는 단방향 그래프는 편도로 왔다갔다 보다 반대 방향의 그래프를 하나 더 만들어서 그래프를 총 2개를 이용해서  왔다갔다 거리를 측정하는게 훨 속도가 빠르다.  

## union find ( 상호 배타적 집합 )
이 알고리즘은 **원소 a 와 b사이의 관계** 에 대해 알아보고자 할 때 사용한다.  
즉, **a가 있는 집단에 b가 있는지, b가 있는 집단에 a가 있는지** 를 알아보기 위해 사용한다.   
- a 와 b의 관계를 알아보기 위해 사용하는 ```find()``` 함수는 다음과 같다.
```
int find(a){
	if(a == parent[a])
		return a;
	else
		return parent[a] = find(parent[a]); // 경로 압축
}
```
- a와 b의 집합을 합칠 때 사용하는 ```union()``` 다음과 같다. (-> 각 집합의 weight(rank)를 유의하여 합쳐야 한다)
```
void union(int a, int b){
	a = find(a);
	b = find(b);
	if(a == b) // 두 수의 부모가 같다면 
		return ; // 함수 종료
		
	// 두 수의 weight (rank)를 비교한다.
	if(rank[a] > rank[b]){  
		parent[b] = a; 		// rank 가 작은 집합의 부모에 다른 수를 집어넣는다. 
		rank[a] += rank[b];	// 랭크도 같이 ! ( 랭크는 랭크가 큰 집합의 부모에 작은 집합의 부모의 랭크를 더한다)
	}
	else{
		parent[a] = b;
		rank[b] += rank[a];	
	}
}
```
